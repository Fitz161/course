---
title: Message-Driven
description: Decoupling Circuit and Software Excitation Using Messages
categories: [Example Projects, Tutorials]
tags: [examples, docs]
weight: 3
---

## Overview
Message-driven programming is a programming paradigm that relies on asynchronous message passing to facilitate communication and collaboration between components. In this paradigm, components of a system communicate by sending and receiving messages instead of directly invoking each other's functions or methods. For example, in the Picker environment, we can use a message-driven approach to decouple the behavior of the circuit from the excitation of the software, thereby **avoiding the constraints of hardware circuit timing**.
In hardware circuit testing, hardware timing refers to the sequence and timing of operations of components in the circuit, which is crucial for the correct operation of the circuit. Software excitation refers to a series of actions or signals generated by software to simulate the impact of external events on the circuit for testing its response. Decoupling hardware timing from software excitation is necessary because it makes the testing process more flexible and efficient. This decoupling also helps **reuse software excitation in different environments**, improving the utilization of testing resources. In conclusion, using message-driven programming to decouple hardware timing and software excitation can **improve the quality and maintainability of testing**, while **reducing complexity**.

![Message-Driven](message.svg)  

Message-driven programming typically involves the following concepts and components:

- **Message**： A message is a unit of data exchanged between components. Messages can be simple data structures, event objects, or even commands. The sender sends a message to a target, and the receiver receives the message from the target.
- **Message Queue**： A message queue is an intermediary for message passing. It is responsible for storing and managing messages sent to it and delivering messages to receivers. Message queues can be based on memory or disk, and can be unicast (one-to-one), multicast (one-to-many), or broadcast (one-to-all).
- **Publish-Subscribe Pattern**：The publish-subscribe pattern is a common implementation of message-driven programming. In this pattern, publishers publish messages to one or more topics, and subscribers subscribe to topics of interest and receive corresponding messages.
- **Message Broker**：A message broker is a middleware component that handles message delivery. It is responsible for receiving and distributing messages, managing message queues, ensuring the reliable delivery of messages, and providing other message-related functions such as message routing, message filtering, message persistence, etc.

## Implementing Message-Driven with Pub/Sub Pattern
The publish/subscribe pattern is a common messaging communication paradigm in software architecture. In this pattern, publishers do not directly send messages to specific recipients, but publish (send) them to an intermediary, known as a message broker. Subscribers express interest in specific message types or topics, indicating which messages they wish to receive. The responsibility of the message broker is to ensure that all clients subscribed to a particular topic receive the corresponding messages.
A key feature of this pattern is the decoupling between publishers and subscribers. They do not need to be aware of each other's existence or communicate directly. This enhances the flexibility and scalability of the system, as publishers and subscribers can be added or removed independently without affecting other parts of the system.

1. Basic Publish/Subscribe Model Implemented with Python's Built-in Queue Module:
- The Publisher class has a message queue and a list of subscribers. When a message is published using the publish method, it is added to the queue and then passed to all subscribed clients by calling their receive methods. The Subscriber class has a receive method that simply prints the received message. 
    ```python
    import queue
    # Publisher class
    class Publisher:
        def __init__(self):
            # Initialize message queue and list of subscribers
            self.message_queue = queue.Queue()
            self.subscribers = []

        def subscribe(self, subscriber):
            # Add a new subscriber to the list of subscribers
            self.subscribers.append(subscriber)

        def publish(self, message):
            # Put the message into the queue and notify all subscribers
            self.message_queue.put(message)
            for subscriber in self.subscribers:
                # Call the subscriber's receive method
                subscriber.receive(message)

    # Subscriber class
    class Subscriber:
        def __init__(self, name):
            # Initialize the subscriber's name
            self.name = name

        def receive(self, message):
            # Print the received message
            print(f"{self.name} received message: {message}")

    # Create an instance of the Publisher
    publisher = Publisher()

    # Create two instances of the Subscriber
    subscriber_1 = Subscriber("Subscriber 1")
    subscriber_2 = Subscriber("Subscriber 2")

    # Add the subscribers to the Publisher's list of subscribers
    publisher.subscribe(subscriber_1)
    publisher.subscribe(subscriber_2)

    # Publish a message
    publisher.publish("Hello World") 
    ``` 
2. Publish/Subscribe Model Implemented with Python's Threading Module: 
- In this example, the Publisher class has a subscriber dictionary, where keys are topics and values are lists of subscribers. The subscribe method adds a subscriber to the list of subscribers for a specified topic. The publish method checks if there are any subscribers for the specified topic, sets an event, and stores the message for each subscriber.
    ```python
    import threading

    # Publisher class
    class Publisher:
        def __init__(self):
            # Initialize the subscriber dictionary, organized by topic
            self.subscribers = {}

        def subscribe(self, subscriber, topic):
            # Subscribe method, adds the subscriber to the specified topic
            if topic not in self.subscribers:
                self.subscribers[topic] = []
            self.subscribers[topic].append(subscriber)

        def publish(self, message, topic):
            # Publish method, sends the message to all subscribers of the specified topic
            if topic in self.subscribers:
                for subscriber in self.subscribers[topic]:
                    # Set the event flag to notify subscribers of new message
                    subscriber.event.set()
                    # Store the message for each subscriber
                    subscriber.message = message

    # Subscriber class
    class Subscriber:
        def __init__(self, name):
            # Initialize the subscriber's name and event flag
            self.name = name
            self.event = threading.Event()
            self.message = None

        def receive(self):
            # Receive method, waits for the event flag to be set
            self.event.wait()
            # Print the received message
            print(f"{self.name} received message: {self.message}")
            # Clear the event flag to prepare for the next message
            self.event.clear()

    # Create an instance of the Publisher
    publisher = Publisher()

    # Create three instances of the Subscriber
    subscriber_1 = Subscriber("Subscriber 1")
    subscriber_2 = Subscriber("Subscriber 2")
    subscriber_3 = Subscriber("Subscriber 3")

    # Subscribe the subscribers to the publisher based on topics
    publisher.subscribe(subscriber_1, "sports")
    publisher.subscribe(subscriber_2, "entertainment")
    publisher.subscribe(subscriber_3, "sports")

    # Publish a message belonging to the 'sports' topic
    publisher.publish("Soccer match result", "sports")

    # Subscriber 1 receives and processes the message
    subscriber_1.receive()
    ``` 

## Subscriber 1 receives and processes the message
Here we take the verification process of NutShell cache as an example to introduce the use of message-driven in verification. For the full code, please refer to the [GitHub repository](https://github.com/yzcccccccccc/XS-MLVP-NutShellCache/tree/master).


```python
from util.simplebus import SimpleBusWrapper
from tools.colorprint import Color as cl
import xspcomm as xsp
import queue

# Request message class, used to encapsulate details of communication requests
class ReqMsg:
    def __init__(self, addr, cmd, user=0x123, size=7, mask=0, data=0):
        self.user = user
        self.size = size
        self.addr = addr
        self.cmd = cmd
        self.mask = mask
        self.data = data
    
    def display(self):
        print(f"[REQ MSG] user {self.user:x}, size {self.size}, addr 0x{self.addr:x} " 
            f"cmd 0x{self.cmd:x}, mask {self.mask:b}, data {self.data:x}")

# Cache Wrapper Class, used to simulate cache behavior and communicate with the external bus
class CacheWrapper:
    def __init__(self, io_bus: SimpleBusWrapper, clk: xsp.XClock, cache_port: xsp.XPort):
        self.xclk = clk
        # Simple Bus Wrapper for external communication
        self.io_bus = io_bus
        # Cache port for potential interaction with external components
        self.cache_port = cache_port

        # Initialize request queue to store incoming request messages
        self.req_que = queue.Queue()
        # Initialize response queue to store processed response messages
        self.resp_que = queue.Queue()
        # Register callback method on the rising edge of the hardware clock for request and response handling
        self.xclk.StepRis(self.__callback)

    # Initiate a read request
    def trigger_read_req(self, addr):
        # Put the read request message into the request queue without waiting for queue lock
        self.req_que.put_nowait(ReqMsg(addr=addr, cmd=self.io_bus.cmd_read))

    # Initiate a write request
    def trigger_write_req(self, addr, data, mask):
        # Put the write request message into the request queue without waiting for queue lock
        self.req_que.put_nowait(ReqMsg(addr=addr, cmd=self.io_bus.cmd_write, mask=mask, data=data))

    # Receive a response
    def recv(self):
        # Wait for the response queue to be non-empty, then retrieve the response
        while self.resp_que.empty():
            self.xclk.Step(1)
        return self.resp_que.get()

    # Read data
    def read(self, addr):
        # Initiate a read request and then wait for and return the response
        self.trigger_read_req(addr)
        return self.recv()

    # Write data
    def write(self, addr, data, mask):
        # Initiate a write request and then wait for and return the response
        self.trigger_write_req(addr, data, mask)
        return self.recv()

    # Reset the cache
    def reset(self):
        # Set the reset signal, wait for a certain number of clock cycles, then clear the reset signal
        self.cache_port["reset"].value = 1
        self.xclk.Step(100)
        self.cache_port["reset"].value = 0
        self.cache_port["io_flush"].value = 0
        # Wait for the request ready signal
        while not self.io_bus.IsReqReady():
            self.xclk.Step(1)

    # Callback method on the rising edge of the hardware clock
    def __callback(self, *a, **b):
        # Handle requests
        if self.io_bus.IsReqSend():
            # If a request is sent, retrieve one from the request queue
            self.req_que.get()
        # Check if the request queue is empty
        if self.req_que.empty():
            # If the request queue is empty, send an invalid request signal to io_bus
            self.io_bus.ReqUnValid()
        else:
            # If the request queue is not empty, send a valid request signal to io_bus
            self.io_bus.ReqSetValid()
            # Retrieve the first request message from the queue
            msg: ReqMsg = self.req_que.queue[0]
            # Execute read or write operation based on the request command type
            if msg.cmd == self.io_bus.cmd_read:
                self.io_bus.ReqReadData(msg.addr)
            if msg.cmd == self.io_bus.cmd_write:
                self.io_bus.ReqWriteData(msg.addr, msg.data, msg.mask)

        # Handle reception
        self.io_bus.port["resp_ready"].value = 1
        # If the response is valid, retrieve the response data from io_bus and put it into the response queue
        if self.io_bus.IsRespValid():
            res = self.io_bus.get_resp_rdata()
            self.resp_que.put_nowait(res)
``` 

In the code above, the message-driven flow proceeds as follows:
1. Encapsulating Software Stimuli:  
- Software stimuli are first encapsulated into ReqMsg objects, which contain all necessary information such as address, command, data, etc. This example uses the Guoke cache verification as an example.

2. Storing Requests with Message Queues:
- Encapsulated requests are placed into the req_que of the CacheWrapper class. This queue acts as a buffer for software stimuli, allowing software to send requests at any time without waiting for an immediate hardware response.

3. Decoupled Callback Mechanism:
- The __callback method of the CacheWrapper class is triggered on the rising edge of the hardware clock. This method checks whether there are pending requests in the request queue and decides whether to process them based on the current hardware state. This is a key step in the decoupling process, as it separates the sending of software stimuli from hardware timing.

4. Simulating Hardware Response:
- Encapsulated requests are placed into the req_que of the CacheWrapper class. This queue acts as a buffer for software stimuli, allowing software to send requests at any time without waiting for an immediate hardware response.

5. Software Receiving Responses:
- Software can retrieve responses from the response queue via the recv method of the CacheWrapper class. This process is synchronous but allows software to check the response queue at any time rather than at specific hardware timing points.

Through this process, software requests (stimuli) and hardware responses (timing) are effectively decoupled. Software can freely send requests, while hardware processes these requests at appropriate timings and generates responses. This separation ensures that software development and testing can be independent of specific hardware behavior, greatly enhancing development efficiency and system scalability. To avoid manually writing code every time, we provide a framework called [MLVP](https://github.com/XS-MLVP/mlvp), which includes a series of ready-made message-driven methods.
