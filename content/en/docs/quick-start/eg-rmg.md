---
title: "Case 2: Random Number Generator"
description: Demonstrating the tool usage with a 16-bit LFSR random number generator, which includes a clock signal, sequential logic, and registers.
categories: [Example Projects, Tutorials]
tags: [examples, docs]
weight: 4
---

## RTL Source Code

In this case, we drive a random number generator with the following source code:

```verilog
module RandomGenerator (
    input wire clk,
    input wire reset,
    input [15:0] seed,
    output [15:0] random_number
);
    reg [15:0] lfsr;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            lfsr <= seed;
        end else begin
            lfsr <= {lfsr[14:0], lfsr[15] ^ lfsr[14]};
        end
    end
 
    assign random_number = lfsr;
endmodule
```
This random number generator consists of a 16-bit LFSR. It takes a 16-bit seed as input and produces a 16-bit random number as output. The LFSR update rule is as follows:

1. XOR the most significant bit and the second most significant bit of the current LFSR value to get a new bit.
2. Shift the original LFSR value to the left by one bit, and place the new bit at the least significant position.
3. Discard the most significant bit.

## Testing Process

During testing, we will create a folder named RandomGenerator containing a file RandomGenerator.v with the RTL source code provided above.

### Building RTL into a Python Module

#### Generating Intermediate Files

Navigate to the RandomGenerator folder and execute the following command:

```bash
picker --autobuild=false RandomGenerator.v -w RandomGenerator.fst -S RandomGenerator -t picker_out_rmg -l python -e --sim verilator
```

This command performs the following actions:

1. Uses RandomGenerator.v as the top file and RandomGenerator as the top module, generates a dynamic library based on the Verilator simulator, and targets the Python language.
2. Enables waveform output, targeting the RandomGenerator.fst waveform file.
3. Includes the files needed to drive the example project (-e) and does not automatically compile after code generation (-autobuild=false).
4. Outputs the files to the picker_out_rmg directory.

The output directory structure is similar to [Adder Verification - Generating Intermediate Files](/docs/quick-start/eg-adder/#Generating Intermediate Files)，and will not be further elaborated here.

#### Building Intermediate Files

Navigate to the `picker_out_rmg` directory and execute the make command to generate the final files.

> Note: The compilation process is similar to [Adder Verification - Compilation Process](/docs/quick-start/eg-adder/#Generating Intermediate Files), and will not be further elaborated here.

The final directory structure is:

```shell
picker_out_rmg
|-- RandomGenerator.fst # Waveform file from the test
|-- UT_RandomGenerator
|   |-- RandomGenerator.fst.hier
|   |-- _UT_RandomGenerator.so # SWIG-generated wrapper dynamic library
|   |-- __init__.py  # Python module initialization file and library definition file
|   |-- libDPIRandomGenerator.a # Library file generated by the simulator
|   |-- libUTRandomGenerator.so # Dynamic library wrapper based on dut_base
|   |-- libUT_RandomGenerator.py # Python module generated by SWIG
|   |-- xspcomm  # xspcomm base library, fixed folder, no need to focus on it
`-- example.py # Example code
```

### Configuring the Test Code

> Note: You need to replace the content in `example.py` to ensure the example project runs as expected.

```python
from UT_RandomGenerator import *
import random

class LFSR_16:
    def __init__(self, seed):
        self.state = seed & ((1 << 16) - 1)

    def step(self):
        new_bit = (self.state >> 15) ^ (self.state >> 14) & 1
        self.state = ((self.state << 1) | new_bit ) & ((1 << 16) - 1)

if __name__ == "__main__":
    dut = DUTRandomGenerator()
    dut.init_clock("clk")

    seed = random.randint(0, 2**16 - 1)

    dut.seed.value = seed
    ref = LFSR_16(seed)

    # reset
    dut.reset.value = 1
    dut.Step(1) # This step performs the initialization assignment
    dut.reset.value = 0 # Remember to reset the signal after setting!
    dut.Step(1)

    for i in range(65536):
        print(f"Cycle {i}, DUT: {dut.random_number.value:x}, REF: {ref.state:x}")
        assert dut.random_number.value == ref.state, "Mismatch"
        dut.Step(1)
        ref.step()

    print("Test Passed, destroy UT_RandomGenerator")
    dut.finalize()
```

### Running the Test Program

Execute `python example.py` in the `picker_out_rmg` directory to run the test program. If the output is `Test Passed, destroy UT_RandomGenerator`, the test has passed.

Example output:

```shell
···
Cycle 65529, DUT: d9ea, REF: d9ea
Cycle 65530, DUT: b3d4, REF: b3d4
Cycle 65531, DUT: 67a9, REF: 67a9
Cycle 65532, DUT: cf53, REF: cf53
Cycle 65533, DUT: 9ea6, REF: 9ea6
Cycle 65534, DUT: 3d4d, REF: 3d4d
Cycle 65535, DUT: 7a9a, REF: 7a9a
Test Passed, destroy UT_RandomGenerator
```
