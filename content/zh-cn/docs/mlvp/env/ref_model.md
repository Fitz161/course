---
title: 如何编写参考模型
weight: 5
---

`参考模型` 用于模拟待验证设计的行为，以便在验证过程中对设计进行验证。在 mlvp 验证环境中，参考模型需要遵循 `Env` 的接口规范，以便能够附加到 `Env` 上，由 `Env` 来完成参考模型的自动同步。

## 参考模型的两种实现方式

mlvp 提供了两种参考模型的实现方式，这两种方式都可以被附加到 `Env` 上，并由 `Env` 来完成参考模型的自动同步。在不同的场景下，可以选择更适合的方式来实现参考模型。

这两种方式分别是 **函数调用模式** 与 **独立执行流模式**，下面将分别介绍这两种方式的具体概念。

### 函数调用模式

**函数调用模式**即是将参考模型的对外接口定义为一系列的函数，通过调用这些函数来驱动参考模型的行为。此时，我们通过输入参数向参考模型发送数据，并通过返回值获取参考模型的输出数据，参考模型通过函数体的逻辑来更新内部状态。

下面是一个简单的函数调用模式的参考模型的定义示例：

例如，这是一个简单的加法器参考模型：

```python
class AdderRefModel():
    def add(self, a, b):
        return a + b
```

在这个参考模型中，不需要任何内部状态，通过一个对外函数接口即可实现参考模型所有功能。

### 独立执行流模式

**独立执行流模式**即是将参考模型的行为定义为一个独立的执行流，它不再受外部主动调用函数控制，而拥有了主动获取输入数据和主动输出数据的能力。当外部给参考模型发送数据时，参考模型不会立即响应，而是将这一数据保存起来，等待其执行逻辑主动获取该数据。

我们用一段代码来说明这种模式，该示例中用到了 mlvp 中提供的相关概念来实现，但目前无需关心这些概念的使用细节。

```python
class AdderRefModel(Model):
    def __init__(self):
        super().__init__()

        self.add_port = DriverPort()
        self.sum_port = MonitorPort()

    async def main():
        while True:
            operands = await self.add_port()
            sum = operands["a"] + operands["b"]
            await self.sum_port(sum)
```

在这里，我们在参考模型构造函数中定义了两类接口，一类为**驱动接口(DriverPort)**，即代码中的`add_port`，用于接收外部输入数据；另一类为**监测接口(MonitorPort)**，即代码中的`sum_port`，用于向外部输出数据。

定义了这两个接口后，上层代码在给参考模型发送数据时，并不会触发参考模型中的某个函数，而是会将数据发送到 `add_port` 这个驱动接口中。同时，上层代码也无法主动获取到参考模型的输出数据了。参考模型的输出数据会通过 `sum_port` 这个监测接口，由参考模型主动输出。

那么参考模型如何去使用这两个接口呢？在参考模型中，有一个 main 函数，这是参考模型执行的入口，当参考模型创建时, main 函数会被自动调用，并在后台持续运行。在上面代码中 main 函数里，参考模型通过不断重复这一过程：等待 `add_port` 中的数据、计算结果、将结果输出到 `sum_port` 中 来实现参考模型的行为。

参考模型会主动向 `add_port` 请求数据，如果 `add_port` 中没有数据，参考模型会等待数据的到来。当数据到来后，参考模型将会进行计算，将计算结果主动的输出到 `sum_port` 中。它的执行过程是一个独立的执行流，不受外部的主动调用控制。当参考模型变得复杂时，其将会含有众多的驱动接口和监测接口，通过独立执行流的方式，可以更好的去处理结构之间的相互关系，尤其是接口之间存在调用顺序的情况。

## 如何编写函数调用模式的参考模型

### 驱动函数匹配



