---
title: 编写规范的验证环境
weight: 2
---

## 概述

一个验证任务编写代码的主体工作可以大致分为两部分，**验证环境的搭建** 和 **测试用例的编写**。

**验证环境的搭建** 旨在完成对待测设计（DUT）的封装，使得验证人员在驱动DUT时，不必面临繁杂的接口信号，而是可以直接使用验证环境中提供的高级接口。如果需要编写参考模型，则参考模型也应是验证环境的一部分。

**测试用例的编写** 则是测试人员使用验证环境提供的接口，编写一个个测试用例，对DUT进行功能验证。

搭建验证环境是一件相当有挑战的事情，当 DUT 极度复杂，其实是在接口信号繁多的情况下，搭建验证环境的难度会更大。此时，若没有一个统一的规范，验证环境的搭建将会变得混乱不堪，一个人编写的验证环境很难被其他人维护。并且当出现新的验证任务与原有验证任务有交集时，因为原有的验证环境缺乏规范，很难将原有的验证环境复用。

本节将会介绍一个规范的验证环境所应该具备的特性，这将有助于理解 mlvp 验证环境的搭建流程。

## 无法复用的验证代码

以一个简单的加法器为例，该加法器拥有两个输入端口 `io_a` 和 `io_b`，一个输出端口 `io_sum`。 在没有意识到验证代码可能会被用于其他验证任务的情况下，我们可能会编写出这样的驱动代码：

```python
def exec_add(dut, a, b):
    dut.io_a.value = a
    dut.io_b.value = b
    dut.Step(1)
    return dut.io_sum.value
```

上述代码中，我们编写了一个 `exec_add` 方法，该方法本质上是对加法器加法操作的一次高层封装。拥有 `exec_add` 方法以后，我们无需再关心如何对加法器的接口信号进行赋值，也无需关心怎样驱动加法器并获取其输出，只需要调用 `exec_add` 方法即可驱动加法器完成一次加法操作。

然而，这个驱动函数却有一个很大的弊端，它直接使用了 DUT 的接口信号来与 DUT 进行交互，这也就意味着，这个驱动函数只能用于这个加法器。

与软件测试不同，在硬件验证中我们每时每刻都能碰到接口结构相同的情况。假设我们拥有另一个具有相同功能的加法器，但其接口信号名称分别是 `io_a_0`、`io_b_0` 和 `io_sum_0`，那么这个驱动函数对这个加法器则直接失效，无法复用。要想驱动，只能重新编写一个新的驱动函数。

一个加法器尚且如此，倘若我们拿到了一个拥有繁杂接口的 DUT，费尽心思为其编写了驱动代码。当后续发现驱动代码需要迁移至另一个相似结构的接口上时，我们将会面临巨大的工作量。例如出现接口名称改变、部分接口缺少但驱动代码中却有引用，部分接口新增等等一系列的问题。

出现这种问题的根本原因在于，我们在验证代码中直接对 DUT 的接口信号进行操作，如下图所示，这种做法是不可取的。

```
+-----------+   +-----------+
|           |-->|           |
| Test Code |   |    DUT    |
|           |<--|           |
+-----------+   +-----------+
```

## 将验证代码与DUT进行解耦

为了解决上述问题，我们需要将验证代码与 DUT 进行解耦，使得验证代码不再直接操作 DUT 的接口信号，而是通过一个中间层来与 DUT 进行交互。这个中间层是人为定义的一个接口结构，在 mlvp 中，我们将这个中间层定义为 `Bundle`，下文也将会使用 `Bundle` 来代指这个中间层。

以上述加法器为例，我们可以定义一个 Bundle 结构，其中包含 `a`, `b` 和 `sum` 三个信号，并让测试代码与这个 Bundle 进行直接交互。

```python
def exec_add(bundle, a, b):
    bundle.a.value = a
    bundle.b.value = b
    bundle.Step(1)
    return bundle.sum.value
```

此时，在 `exec_add` 中并没有直接操作 DUT 的接口信号，甚至不知道 DUT 中的接口信号名称是什么，其直接与我们在 Bundle 中定义的接口信号进行交互。

那如何让 Bundle 中的信号与 DUT 的引脚进行关联呢？只需要添加一个连接操作即可，最简单的连接方法是，我们直接指定 Bundle 中的每一个信号具体与 DUT 的哪一个引脚相连，例如：

```
bundle.a   <-> dut.io_a
bundle.b   <-> dut.io_b
bundle.sum <-> dut.io_sum
```

如果 DUT 的接口信号名称发生了变化，我们只需要修改这个连接过程，例如：

```
bundle.a   <-> dut.io_a_0
bundle.b   <-> dut.io_b_0
bundle.sum <-> dut.io_sum_0
```

这样一来，无论 DUT 的接口如何变化，只要其拥有相同的结构，都可以通过原有的驱动代码来驱动，需要修改的仅仅是连接过程。此时的验证代码与 DUT 的关系如下图所示：

```
+-----------+  +--------+             +-----------+
|           |->|        |             |           |
| Test Code |  | Bundle |-- connect --|    DUT    |
|           |<-|        |             |           |
+-----------+  +--------+             +-----------+
```

在 mlvp 中，我们为 `Bundle` 提供了简洁的定义过程以及大量的连接方法，可极大方便中间层的定义与连接，除此之外，`Bundle` 还提供了大量的实用功能来帮助验证人员更好的与接口信号进行交互。


## 将 DUT 接口进行分类驱动

